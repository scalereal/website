---
title: Test Automation
description: Testing notion to sr blogs automation
categories:
  - web
date: '2025-10-31'
tags:
  - test
  - automation
author: Prathamesh Gunde
image: >-
  https://prod-files-secure.s3.us-west-2.amazonaws.com/919ce7fa-5297-4567-a260-4e8ca0407346/28320077-452f-412a-be1c-8c9021eda13a/image-1-.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB46645EOOSEC%2F20251031%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20251031T052303Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEEUaCXVzLXdlc3QtMiJHMEUCIQD2JmeGH2Hu61fJbr9C3li%2B4YvQv%2B%2BopqEpuYXnWMpP6wIgCqylrp2i7AvoQtCK8zTOCYLrOD%2FU%2BbM5pRT%2Bv%2Fk2LtgqiAQI%2Fv%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARAAGgw2Mzc0MjMxODM4MDUiDAEmfjSh3H6CcGRBZSrcA6DVDqJEZ241fdkn80mkdca2kJzqghnWHtREWTVGLpzpQfKJRW9cSMKaSi%2FqG8ngv%2FyGY2tlRPw64RZ52gfGMzlR2liQuRVtDuozBSzFDKlb6Q9wTVuSPsx97cXUlGaatMJBXI9POAXommXYn6nblvBxN5K396qrXj5gN3z5Je%2FyRlPKGn%2FxTYIL%2BA16AVK0nvrHaqrswkRSXfIiNqMW1NnA9R14ZIcGDXC%2Fsu8B9QJu2Zmtq8079vpvhee5PKyRyw0YU0v%2BMw0Wu9ioL1yCkKuVsJFFqucwrG44gPR%2B%2BuXEyRdrdzXh7VL58Ak9p7uvdVqzIBAH4yKf%2BNDr6brt9YLFEq9BHPfz5grLmDOL9ivKO3nh%2BGmDZlhxfN88Pw0vSHZX%2BPtT%2FJSATL8Mxg%2B%2FoRwY82UH2MqxIS%2FrYdl%2BYpYylhDX6NXiLy6%2FvS%2FgQvWAAb%2Blk3uVYC2vjUsgy1h5pMUrcfUbD5nUMInosEMbF99yHdBbVlImI5cbqwUoZlB1TLKTi9n8t0QfbPecTRv3v3M3Qky5xgmb6cDv4T0eGu5yepuoOL3ke2Du3Og8K9O7QEDMZgP0FFiAsm3xgBcjQOuoS0BXLR2SQ9jlW%2FUyhOboZcg5bpGvwKbdsLd6MNGDkcgGOqUBFJbfsUkkYu5gqIFXdwD2G5DUV2I%2FVK%2FLOI9o4pkH%2FOr%2Bz%2BV3I%2BB%2FulFG31U%2FQb1PmnF8qyeCfr8cftAkWcPdkbGi7wxGVNYt7atQIvdpGvVflDzwAYIR0%2B7iJuxnlWd4ePRs4NgojsbGSb01%2F8Oc%2Bk9LrB5tLnpdKnaAVOl0Kgifr7FnUx%2FrKBxuR60shQjHpPE7JxIedKzcUQR12YkxWepZ3YwV&X-Amz-Signature=e04bbce733bdb0bf265368a3945c51e1e67a54af770496feaa85b680ddd52aa2&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject
url: web/2025/10/08/test-automation.html
draft: false
---

# **The Problem: Coding Without Thinking**


Let’s imagine: You get a new feature request, open your code editor, and immediately start typing. Sound familiar? Most developers fall into this trap – we dive straight into coding without taking a moment to think about the structure and design of what we are building.


This “**code first, think later**” approach leads to a cascade of problems:

- Messy, unreadable code that’s hard to maintain
- Hours spent refactoring what could have been written cleanly from the start
- Components that do too many things at once
- Code that’s difficult to test and reuse
- Endless debugging sessions trying to sort out complex logic

The truth is, we often write code randomly and then spend precious time refactoring it later. But what if there was a better way?


# **The Solution: Component Design Thinking**


**Component design** is the practice of thinking through your component structure before writing a single line of code. It’s about asking the right questions upfront:

- What is this component’s single responsibility?
- How can I break this down into smaller, manageable pieces?
- What will my component hierarchy look like?
- How will these components interact with each other?

Good developers are the ones who refactor less code, not because they are lazy, but because they invest time in thinking before coding. This approach saves enormous amounts of time in the long run.


# **Why Component Design Matters**


When you practice component design, you get several benefits:

- **Less Refactoring**: Your code architecture is thought out from the beginning, reducing the need for major structural changes later.
- **Modular Code**: Each component has a clear purpose and can be easily understood, modified, and reused.
- **Better Testability**: Smaller, focused components are much easier to test than large, multi-purpose ones.
- **Improved Readability**: Your code tells a story that other developers (including future you) can easily follow.
- **Easier Maintenance**: When bugs arise or features need updates, you know exactly where to look and what to change.

# **The Problem: Coding Without Thinking**


Let’s imagine: You get a new feature request, open your code editor, and immediately start typing. Sound familiar? Most developers fall into this trap – we dive straight into coding without taking a moment to think about the structure and design of what we are building.


This “**code first, think later**” approach leads to a cascade of problems:

- Messy, unreadable code that’s hard to maintain
- Hours spent refactoring what could have been written cleanly from the start
- Components that do too many things at once
- Code that’s difficult to test and reuse
- Endless debugging sessions trying to sort out complex logic

The truth is, we often write code randomly and then spend precious time refactoring it later. But what if there was a better way?


# **The Solution: Component Design Thinking**


**Component design** is the practice of thinking through your component structure before writing a single line of code. It’s about asking the right questions upfront:

- What is this component’s single responsibility?
- How can I break this down into smaller, manageable pieces?
- What will my component hierarchy look like?
- How will these components interact with each other?

Good developers are the ones who refactor less code, not because they are lazy, but because they invest time in thinking before coding. This approach saves enormous amounts of time in the long run.


# **Why Component Design Matters**


When you practice component design, you get several benefits:

- **Less Refactoring**: Your code architecture is thought out from the beginning, reducing the need for major structural changes later.
- **Modular Code**: Each component has a clear purpose and can be easily understood, modified, and reused.
- **Better Testability**: Smaller, focused components are much easier to test than large, multi-purpose ones.
- **Improved Readability**: Your code tells a story that other developers (including future you) can easily follow.
- **Easier Maintenance**: When bugs arise or features need updates, you know exactly where to look and what to change.

# **The SOLID Principles in Component Design**


The SOLID principles, especially the **Single Responsibility Principle (SRP)**, are crucial for component design:


**Single Responsibility Principle**: Every component should have one reason to change. If your component file is over 150 lines, it’s probably doing too much.


**Example**: Instead of creating one massive `ProductCard` component that handles displaying product info, managing wishlist state, handling purchase logic, and showing promotional labels, break it down:

- `ProductCard` → Displays basic product information
- `WishlistButton` → Handles wishlist functionality
- `PurchaseButton` → Manages purchase logic
- `PromotionalLabel` → Shows special offers or “New” labels

# **Component Composition: Building with** [**Lego Blocks**](https://en.wikipedia.org/wiki/Lego)


Think of components like Lego blocks. Each piece serves a specific purpose, but when combined, they create something more complex and beautiful. This is **component composition** – building larger features by combining smaller, focused components.


For example, a “New” label on some product cards:


`Card component` → SRP: showing card information


`LabeledCard component` (Higher Order Component) → Takes any card component and adds a label to it


This approach means you can reuse the basic `Card` anywhere, and the labeling logic is separate and reusable too.


# **Real-World Example: YouTube Navigation Design**


Let’s look at how YouTube handles its navigation to understand good component design in action.

- **Collapsed state**

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/919ce7fa-5297-4567-a260-4e8ca0407346/88711d63-c42e-457a-896e-801aa1cf6173/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB466RA4PNA43%2F20251031%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20251031T052303Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEEUaCXVzLXdlc3QtMiJIMEYCIQDbCIkDy80Y3dLpHFems0v7fY7qAWxtGLNFD%2FbhYuw%2BCQIhALMJ7fIcA0JLonkN1skeBrl%2B8hvq6AeTXgOTVr6fAyGZKogECP7%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEQABoMNjM3NDIzMTgzODA1IgzHyH%2BCJWex2MImfe4q3AMaRf%2FKggJVyKyCfEtgtIu6x%2Fv04E3oC49vSbSY2uwiK7hBI0%2B3Z%2BqD2Gg7LXh%2F3CiqlWhvtC7IMByNEHZk3ZxhIv9uLzBfxxHwTpWcotBvLaHvijNazv3p28Xlln8Jai4I9vsjXsEb%2FSkbXY%2FFuDiFK6YPZCTvlcxL5Fevp8MoeDI0HS0tdlCR5W9qvBhGGWomyF6HFTrbZs58m4GdDOcYT0tRtQr2AWsadK8MGSwb193zgVJc8zCkZ1FizpNyrYyY86PSklJLh4JvigV05VpNdsnzrGQ9rI3anzO%2F%2FJ4icrriil64TafXrKqU2%2Fs3Q8BZjT8gQP6kBsdemlWED9UkZDaRp7%2BJt9NybPg3d%2FJ4Qr1BKwWjfyXGl9HKbNwbuuRdjaUXZNp2Hr9hCpJ6v4HcHU5hkAEv8AcBj2%2BLMG7AJqI7pAnSxr9pZnCv4C2e5zc4MVYl1MwnVpVOqXXT%2Bw%2F%2BcsVZjIv292yyrRlIx1trUVbEDyibZN4gmxN2NF%2BIIsjlpryv7GQbbqAbiPUhTOTfJTwpqZx%2B5oL71%2FNGZzpiEAikWVUUokX%2FI7OTsPtIM30XFH%2F9rL30QsnkiNaT6FBA0b9ORYLwmXqZM1P4lgNahkML7ZYSBHFcn%2Bx6kzD5g5HIBjqkAXcBQ1HgB5ad9UwPKTPoM%2B7CDj1TX7GIKylEw%2Fo2fuPYe7muy7GjPQRkD4YqORmBNxClRhjtR8wqSOqM1DGH3Ml2kNXtKfeU6jnBWqgyzT3%2Bmvp33eWtIMW3c7fPjGGDlMiMYrwjDLoo72gRi3O2M%2Fi8kczWspv3T6Ni1i7eVoPE4al7AQNItPE49kYobGKsZjesAbawT9f9aSGMPmkDpiQJk%2Bup&X-Amz-Signature=50154ad31178492c3794d93897a2ae286a3e0597feb25da248ea0880fbda6c97&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject)


# **The Good Implementation**


YouTube’s approach (and what you should do):


```html
<Header>
  <MenuButton>
</Header>

<Body>
  <LeftNavContainer>
    <CollapsedMenu>
      <Item1>
      <Item2>
      <Item3>
    </CollapsedMenu>
    <ExpandedMenu>
      <Section1>
        <Heading>
        <ExpandedItem1>
        <ExpandedItem2>
      </Section1>
    </ExpandedMenu>
  </LeftNavContainer>
  <MainContent>
    <!-- Your main content here -->
  </MainContent>
</Body>
```


# **Why This Works Better**


**Layout Control**: The main container can easily adjust its width based on navigation state since both are in the same parent container.


**Separate State Management**: Collapsed and expanded menus are separate components, making it easy to conditionally render the appropriate one.


**CSS Simplicity**: No complex positioning required – everything flows naturally.


**Testing Made Easy**: You can test collapsed and expanded states independently.


**Performance Benefits**: Supports lazy loading and code splitting – you can load expanded menu components only when needed.


# **Common Mistakes Developers Make**

1. **Adding navigation to the header** when it should be in the body
2. **Not separating expanded and collapsed states** into different components
3. **Writing components over 150 lines** without breaking them down
4. **Mixing multiple responsibilities** in a single component
5. **Skipping the design phase** and jumping straight into coding
